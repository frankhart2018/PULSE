<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>vm.c - PCV</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous">
    </script>
  </head>
  <body>
    <pre class="prettyprint linenums" style="width: 50%; float: left;">
      #include &lt;stdio.h&gt;
      #include &lt;math.h&gt;
      #include &lt;stdlib.h&gt;

      #include "../includes/common.h"
      #include "../includes/compiler.h"
      #include "../includes/debug.h"
      #include "../includes/scanner.h"
      #include "../includes/vm.h"
      #include "../includes/iota.h"

      #define BOUND 256

      void initVM(VM* vm) {
        vm-&gt;top = -1;
        vm-&gt;length = 0;
      }

      void freeVM(VM* vm) {

      }

      Value* create_new(VM* vm, Value* a) {
        Value* new_a = (Value*)malloc(vm-&gt;length + BOUND);
        for(int i=0; i&lt;vm-&gt;length; i++)
          new_a[i] = a[i];
        vm-&gt;length += BOUND;
        return new_a;
      }

      void push(VM* vm, Value val) {
        if(vm-&gt;top == vm-&gt;length - 1)
          vm-&gt;stack = create_new(vm, vm-&gt;stack);
        vm-&gt;stack[++vm-&gt;top] = val;
      }

      Value pop(VM* vm) {
        return vm-&gt;stack[vm-&gt;top--];
      }

      void display(VM* vm) {
        if (vm-&gt;top == -1)
            printf("Stack is Empty\n");
        else {
            printf("Stack: ");
            for (int i = 0; i &lt;= vm-&gt;top; i++)
                printf("%.1f ", vm-&gt;stack[i]);
            printf("\n");
        }
      }

      void modulo(VM* vm) {
        int b = (int)pop(vm);
        int a = (int)pop(vm);
        push(vm, a % b);
      }

      void power(VM* vm) {
        double b = pop(vm);
        double a = pop(vm);
        push(vm, pow(a, b));
      }

      static InterpretResult run(VM* vm) {
      #define READ_BYTE() (*vm-&gt;ip++)
      #define READ_CONSTANT() (vm-&gt;iota-&gt;constants.values[READ_BYTE()])

      #define BINARY_OP(op) \
          do { \
            double b = pop(vm); \
            double a = pop(vm); \
            push(vm, a op b); \
          } while(false) \

        for( ; ; ) {
      #ifndef DEBUG_TRACE_EXECUTION
          printf("          ");
          for(Value* slot = vm.stack; slot &lt; vm.stackTop; slot++) {
            printf("[ ");
            printValue(*slot);
            printf(" ]");
          }
          printf("\n");
          disassembleInstruction(vm.iota, (int)(vm.ip - vm.iota-&gt;code));
      #endif
          uint8_t instruction;
          switch(instruction = READ_BYTE()) {
            case OP_CONSTANT: {
              Value constant = READ_CONSTANT();
              push(vm, constant);
              break;
            }
            case OP_ADD: BINARY_OP(+); break;
            case OP_SUBTRACT: BINARY_OP(-); break;
            case OP_MULTIPLY: BINARY_OP(*); break;
            case OP_DIVIDE: BINARY_OP(/); break;
            case OP_MODULO: modulo(vm); break;
            case OP_POWER: power(vm); break;
            case OP_NEGATE: push(vm, -pop(vm)); break;
            case OP_RETURN: {
              printValue(pop(vm));
              printf("\n");
              return INTERPRET_OK;
            }
          }
        }

      #undef BINARY_OP
      #undef READ_CONSTANT
      #undef READ_BYTE
      }

      InterpretResult interpret(VM* vm, const char* source) {
        Iota iota;
        initIota(&iota);

        if(!compile(source, &iota)) {
          freeIota(&iota);
          return INTERPRET_COMPILE_ERROR;
        }

        vm-&gt;iota = &iota;
        vm-&gt;ip = vm-&gt;iota-&gt;code;

        InterpretResult result = run(vm);

        freeIota(&iota);
        return result;
      }
    </pre>
  </body>
</html>
